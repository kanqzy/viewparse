<!DOCTYPE html>
<html>
<head>
<title>Ve.lang.grammar.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="ve%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D%E8%AF%B4%E6%98%8E">Ve编程语言语法介绍说明</h1>
<h2 id="%E5%85%B3%E4%BA%8Eve%E8%AF%AD%E8%A8%80">关于Ve语言</h2>
<p>Ve:Very Easy的简称
Ve是一个轻量级的数据处理编程语言。
把Ve语言看成是一个放大版的数学公式吧，
Ve除了处理数字之外还可以处理逻辑，文本、集合等常见数据</p>
<h3 id="%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">基本类型</h3>
<p>我们提供了最简单的数据单元：数字，整数，文本，是否</p>
<h4 id="%E6%95%B0%E5%AD%97%E3%80%81%E6%95%B4%E6%95%B0">数字、整数</h4>
<p>并没有提供float,double等数字类型。<br>
如果当前的类型为数字类型，那么最终生成的其它的语言都会对应浮点型。
Ve支持科学计数法。</p>
<pre class="hljs"><code><div>def a:int=300;
def b=3e2;
print(a==b);//true;
def c:number=100.2;
</div></code></pre>
<h4 id="%E6%96%87%E6%9C%AC">文本</h4>
<p>使用双引号、单引号包起来的文本串<br>
支持文本内部跨行显示<br>
支持模板文本</p>
<pre class="hljs"><code><div>string a='eeeee';
string b='eee
eee';
string c='两个@{a},@{b}';
string d='两个'+a+','+b;
print(d==c) //true
</div></code></pre>
<h4 id="%E6%98%AF%E5%90%A6">是否</h4>
<p>表达逻辑真与假</p>
<pre class="hljs"><code><div>def a:bool=true;
def b=false;
</div></code></pre>
<p>提供了处理复杂数据结的数据类型：对象、数组、列表</p>
<h4 id="%E5%AF%B9%E8%B1%A1">对象</h4>
<p>对象类型类似于JSON</p>
<pre class="hljs"><code><div>def data={ account:'kankan',pwd:'12345',sex:true};
def data:{ account:string,pwd:string,sex:bool}=={ account:'kankan',pwd:'12345',sex:true};
def data={
    account:string='kankan',
    pwd:string,
    sex:bool
}
print(data.pwd)//null
print(data.pwd)//null
print(data.sex)//null
</div></code></pre>
<h4 id="%E6%95%B0%E7%BB%84">数组</h4>
<p>数组里面的数据类型必须一致</p>
<pre class="hljs"><code><div>def a:int[]=[1,2,3];
def a:string[]=['1','2','3'];
def a:int[]=[1,2,'string'];//error 数组里面的每一项都应该是数字类型
def a:any[]=[1,2,'eee'];//ok ,数组里面的每一项都是any类型
def a=[1,2,3]//自动推断为int[]
def a=[1,2,'eee']//自动推为any[];
def a:{a:string,b:number}[]=[];//定义一个数组，里面的每一项都是{a:string,b:number}类型
def a=int[1,2,3,4];
</div></code></pre>
<h4 id="any">Any</h4>
<p>any类型表示任意类型，也可以理解为无类型，所有的数据类型都继承该类型Any</p>
<pre class="hljs"><code><div>def a:any=123;
def b:any=true;
</div></code></pre>
<h4 id="%E6%9E%9A%E4%B8%BE">枚举</h4>
<p>枚举默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。<br>
被指定的元素值不参于元素编号。</p>
<pre class="hljs"><code><div> enum Color {Red, Green, Blue}
 def c:Color=Color.Red;
 print(c);//0
 print(c.toString())://Red
 //当然也可以指定值
 enum Color {Red:2, Green:0, Blue:3}
 print(Color.Red)//Red
 print((int)Color.Red)// 2
 print(Color.Red.toString());// Red
 
</div></code></pre>
<h4 id="fun">fun</h4>
<p>fun类型</p>
<pre class="hljs"><code><div>fun sum(a:number,b:number):number{return a+b;}
fun action()
{
    //do something...
}
fun action(...args:string[]):void
{

}
fun action(a:string='eee',b:number='eesss')
{
   //如果返回值为void,可省略
}
</div></code></pre>
<h4 id="null">null</h4>
<pre class="hljs"><code><div>def a=null;
print(a):// null
print(a.toString())//error...
print(a?.toString())//null
print(a is null)//true
a?=1;//如果a为空，则赋值为1
</div></code></pre>
<p>基于文本的类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>日期</td>
<td>date</td>
<td></td>
</tr>
<tr>
<td>正则</td>
<td>regex</td>
<td></td>
</tr>
<tr>
<td>颜色</td>
<td>color</td>
<td></td>
</tr>
<tr>
<td>网址</td>
<td>url</td>
<td></td>
</tr>
<tr>
<td>路径</td>
<td>path</td>
<td></td>
</tr>
<tr>
<td>文件</td>
<td>file</td>
<td></td>
</tr>
<tr>
<td>文件夹</td>
<td>folder</td>
<td></td>
</tr>
<tr>
<td>图像</td>
<td>image</td>
<td></td>
</tr>
<tr>
<td>字体</td>
<td>font</td>
<td></td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><div>def c=/2018-9-25/date;
def c='2018-9-25'date;//注意此时的date需要紧挨着
def url='http://www.baidu.com'url;
def color=/#fff/color;
</div></code></pre>
<h3 id="%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">变量声明</h3>
<h4 id="def-%E5%A3%B0%E6%98%8E">def 声明</h4>
<pre class="hljs"><code><div>def a=10;
def a=20,b=30,c:color='#ffff';
</div></code></pre>
<h4 id="const%E5%A3%B0%E6%98%8E">const声明</h4>
<p>const 声明的值在第一次赋值后，不可再重新赋值修改</p>
<pre class="hljs"><code><div>const a=20;
a=30 //error
</div></code></pre>
<h3 id="%E6%8E%A5%E5%8F%A3">接口</h3>
<pre class="hljs"><code><div>interface LabelledValue {
  label: string;
}
</div></code></pre>
<h3 id="%E7%B1%BB">类</h3>
<pre class="hljs"><code><div>class Greeter {
    greeting: string;
    new(message: string)
    {
        this.greeting = message;
    }
    greet():string
    {
        return &quot;Hello, &quot; + this.greeting;
    }
}
</div></code></pre>
<h3 id="%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">箭头函数</h3>
<pre class="hljs"><code><div>def add:(a:number,b:number)=&gt;number=(a,b)=&gt;a+b;
print add(1,2);//3
</div></code></pre>
<h3 id="%E6%B3%9B%E5%9E%8B">泛型</h3>
<pre class="hljs"><code><div>fun identity&lt;T&gt;(arg: T):T
{
    return arg;
}
//下面的泛型只能接收string
fun identity&lt;T:string&gt;(arg:T):T
{
    return arg;
}
</div></code></pre>
<h3 id="%E5%8C%85-%E5%BC%95%E7%94%A8">包 引用</h3>
<pre class="hljs"><code><div>package nc{
    class classA
    {

    }
}
// 其它文件代码文件引用
use nc;
use nc.class1 classOne;
def a=new class1();
def b=new classOne();

//其它代码引用
use nc;
use nc.web;
use nc.web.class2 classSecond;
def a=new web.class2();
def a=new class2();
def a=new classSecond();
</div></code></pre>
<h3 id="%E5%85%B3%E9%94%AE%E5%AD%97">关键字</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>def</td>
<td></td>
</tr>
<tr>
<td>const</td>
<td></td>
</tr>
<tr>
<td>if,else if,else</td>
<td></td>
</tr>
<tr>
<td>while,do...while</td>
<td></td>
</tr>
<tr>
<td>for,for in</td>
<td></td>
</tr>
<tr>
<td>switch,switch case,default</td>
<td></td>
</tr>
<tr>
<td>fun</td>
<td></td>
</tr>
<tr>
<td>class,enum,interface,extend</td>
<td></td>
</tr>
<tr>
<td>public,private,static,sealed</td>
<td></td>
</tr>
<tr>
<td>package</td>
<td></td>
</tr>
<tr>
<td>use</td>
<td></td>
</tr>
<tr>
<td>get,set</td>
<td></td>
</tr>
<tr>
<td>new,is,as,not,contain,start,end,match</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</h3>
<p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。Ve 有丰富的内置运算符，分类如下：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
<li>其他运算符</li>
</ul>
<h4 id="%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</h4>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>把两个操作数相加</td>
<td>A + B 将得到 30</td>
</tr>
<tr>
<td>-</td>
<td>从第一个操作数中减去第二个操作数</td>
<td>A - B 将得到 -10</td>
</tr>
<tr>
<td>*</td>
<td>把两个操作数相乘</td>
<td>A * B 将得到 200</td>
</tr>
<tr>
<td>/</td>
<td>分子除以分母</td>
<td>B / A 将得到 2</td>
</tr>
<tr>
<td>%</td>
<td>取模运算符，整除后的余数</td>
<td>B % A 将得到 0</td>
</tr>
<tr>
<td>++</td>
<td>自增运算符，整数值增加 1</td>
<td>A++ 将得到 11</td>
</tr>
<tr>
<td>--</td>
<td>自减运算符，整数值减少 1</td>
<td>A-- 将得到 9</td>
</tr>
</tbody>
</table>
<h4 id="%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">关系运算符</h4>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>检查两个操作数的值是否相等，如果相等则条件为真。</td>
<td>(A == B) 不为真。</td>
</tr>
<tr>
<td>!=</td>
<td>检查两个操作数的值是否相等，如果不相等则条件为真。</td>
<td>(A != B) 为真。</td>
</tr>
<tr>
<td>&gt;</td>
<td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
<td>(A &gt; B) 不为真。</td>
</tr>
<tr>
<td>&lt;</td>
<td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
<td>(A &lt; B) 为真。</td>
</tr>
<tr>
<td>&gt;=</td>
<td>检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>
<td>(A &gt;= B) 不为真。</td>
</tr>
<tr>
<td>&lt;=</td>
<td>检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>
<td>(A &lt;= B) 为真。</td>
</tr>
</tbody>
</table>
<h4 id="%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</h4>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>
<td>(A &amp;&amp; B) 为假。</td>
</tr>
<tr>
<td>||</td>
<td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>
<td>(A || B) 为真。</td>
</tr>
<tr>
<td>!</td>
<td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td>!(A &amp;&amp; B) 为真</td>
</tr>
<tr>
<td>^</td>
<td>异或，如果同时为真，则为假，否则为真</td>
<td>A^B</td>
</tr>
</tbody>
</table>
<h4 id="%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</h4>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td>
<td>C = A + B 将把 A + B 的值赋给 C</td>
</tr>
<tr>
<td>+=</td>
<td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
<td>C += A 相当于 C = C + A</td>
</tr>
<tr>
<td>-=</td>
<td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
<td>C -= A 相当于 C = C - A</td>
</tr>
<tr>
<td>*=</td>
<td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
<td>C *= A 相当于 C = C * A</td>
</tr>
<tr>
<td>/=</td>
<td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
<td>C /= A 相当于 C = C / A</td>
</tr>
<tr>
<td>%=</td>
<td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>
<td>C %= A 相当于 C = C % A</td>
</tr>
<tr>
<td>?=</td>
<td>null赋值</td>
<td>a?='123' 如果a为null,则a 当前取会为'123'</td>
</tr>
</tbody>
</table>
<h4 id="%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6">其他运算符</h4>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>??</td>
<td>null条件</td>
<td>def b=a??'123';如果a为null,则b='123',否则b=a</td>
</tr>
<tr>
<td>?:</td>
<td>条件表达式</td>
<td>如果条件为真 ? 则为 X : 否则为 Y</td>
</tr>
<tr>
<td>is</td>
<td>判断对象是否为某一类型。</td>
<td>If( Ford is Car) // 检查 Ford 是否是 Car 类的一个对象。</td>
</tr>
<tr>
<td>as</td>
<td>强制转换，即使转换失败也不会抛出异常。</td>
<td></td>
</tr>
<tr>
<td>match</td>
<td>文本格式判断</td>
<td>判断当前文本是否满格式 bool isMath=c match new Regex('[\d]+')</td>
</tr>
<tr>
<td>contain</td>
<td>是否包含</td>
<td>def a= '123' contain '1'<br/> def a=int[]{1,2,3} contain 1</td>
</tr>
<tr>
<td>not</td>
<td>否定运算</td>
<td>ford not is Car ,not match,not contain</td>
</tr>
</tbody>
</table>
<h4 id="ve%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7">Ve中的运算符优先级</h4>
<table>
<thead>
<tr>
<th>类别</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td>后缀</td>
<td>() [] -&gt; . ++ - -</td>
<td>从左到右</td>
</tr>
<tr>
<td>一元</td>
<td>+ - !  ++ - - (type)</td>
<td>从右到左</td>
</tr>
<tr>
<td>乘除</td>
<td>* / %</td>
<td>从左到右</td>
</tr>
<tr>
<td>加减</td>
<td>+ -</td>
<td>从左到右</td>
</tr>
<tr>
<td>关系</td>
<td>&lt; &lt;= &gt; &gt;=</td>
<td>从左到右</td>
</tr>
<tr>
<td>相等</td>
<td>==, !=, is, as ,match contain,not is,not match,not contain</td>
<td>从左到右</td>
</tr>
<tr>
<td>逻辑与 AND</td>
<td>&amp;&amp;</td>
<td>从左到右</td>
</tr>
<tr>
<td>逻辑或 OR</td>
<td>||</td>
<td>从左到右</td>
</tr>
<tr>
<td>条件</td>
<td>?: ??</td>
<td>从右到左</td>
</tr>
<tr>
<td>赋值</td>
<td>= ?= += -= *= /= %</td>
<td>从右到左</td>
</tr>
<tr>
<td>逗号</td>
<td>,</td>
<td>从左到右</td>
</tr>
</tbody>
</table>
<h3 id="%E8%AF%AD%E5%8F%A5">语句</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>for</td>
<td><code>/for\((\{|((?!(statement)).)*(statement)?)/</code></td>
</tr>
<tr>
<td>if</td>
<td><code>/if\((\{|((?!(statement)).)*(statement)?)(eif\((\{|((?!(statement)).)*(statement)?))*(else(\{|((?!(statement)).)*(statement)?))?/</code></td>
</tr>
<tr>
<td>switch</td>
<td><code>/switch\(\{ /</code></td>
</tr>
<tr>
<td>case</td>
<td><code>/case((?!(case|default)).)* /</code></td>
</tr>
<tr>
<td>return</td>
<td><code>/return(((?!(statement)).)*(statement)?)/</code></td>
</tr>
<tr>
<td>default</td>
<td><code>/default((?!(case|default)).)*/</code></td>
</tr>
<tr>
<td>do</td>
<td><code>/do(\{|((?!(statement)).)*(statement)?)while\(/</code></td>
</tr>
<tr>
<td>while</td>
<td><code>/while\((\{|((?!(statement)).)*(statement)?)/</code></td>
</tr>
<tr>
<td>fun</td>
<td><code>/funword\(\(?\{/</code></td>
</tr>
<tr>
<td>break</td>
<td><code>/break/</code></td>
</tr>
<tr>
<td>continue</td>
<td><code>/continue/</code></td>
</tr>
</tbody>
</table>
<h3 id="%E5%B0%81%E8%A3%85">封装</h3>
<p>public：所有对象都可以访问；如果对象没有任何修饰，则默认是public<br>
private：对象本身在对象内部可以访问；<br>
static :所有对象共用</p>
<h3 id="ve%E5%87%BD%E6%95%B0">Ve函数</h3>
<p>Ve中定义函数
当定义一个方法时，从根本上说是在声明它的结构的元素。在 Ve中，定义方法的语法如下：</p>
<p><Access Specifier> <Method Name>(Parameter List)<Return Type>
{
Method Body
}
下面是方法的各个元素：<br>
Access Specifier：访问修饰符，这个决定了变量或方法对于另一个类的可见性。<br>
Return type：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 void。返回类型为void时，可省略<br>
Method name：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。<br>
Parameter list：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。<br>
Method body：方法主体，包含了完成任务所需的指令集。<br>
实例</p>
<pre class="hljs"><code><div>class NumberManipulator
{
   public FindMax( num1:int,num2:int):int
   {
      /* 局部变量声明 */
      int result;
      if (num1 &gt; num2)
         result = num1;
      else
         result = num2;

      return result;
   }
   ...
}
</div></code></pre>
<h3 id="%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81">继承与多态</h3>
<p>基类和派生类<br>
一个类可以派生自多个类或接口，这意味着它可以从多个基类或接口继承数据和函数。
Ve 中创建派生类的语法如下：</p>
<pre class="hljs"><code><div>&lt;acess-specifier&gt; class &lt;base_class&gt;
{
  ...
}
class &lt;derived_class&gt; : &lt;base_class&gt;
{
 ...
}
</div></code></pre>
<p>多态</p>
<pre class="hljs"><code><div>  class Printdata
   {
      print(int i)
      {
         print(&quot;Printing int: @{i}&quot; );
      }
      print(string s)
      {
         print(&quot;Printing string: @{s}&quot;);
      }
   }
</div></code></pre>
<h3 id="ve-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">Ve 异常处理</h3>
<p>假设一个块将出现异常，一个方法使用 try 和 catch 关键字捕获异常。try/catch 块内的代码为受保护的代码，使用 try/catch 语法如下所示：</p>
<pre class="hljs"><code><div>try
{
   // 引起异常的语句
}
catch(ExceptionName e1)
{
   // 错误处理代码
}
finally
{
   // 要执行的语句
}
</div></code></pre>
<h3 id="ve-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB">Ve 中的异常类</h3>
<table>
<thead>
<tr>
<th>异常类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ve.IndexOutOfRangeException</td>
<td>处理当方法指向超出范围的数组索引时生成的错误。</td>
</tr>
<tr>
<td>Ve.ArrayTypeMismatchException</td>
<td>处理当数组类型不匹配时生成的错误。</td>
</tr>
<tr>
<td>Ve.NullReferenceException</td>
<td>处理当依从一个空对象时生成的错误。</td>
</tr>
<tr>
<td>Ve.DivideByZeroException</td>
<td>处理当除以零时生成的错误。</td>
</tr>
<tr>
<td>Ve.InvalidCastException</td>
<td>处理在类型转换期间生成的错误。</td>
</tr>
</tbody>
</table>
<h3 id="ve-%E7%89%B9%E6%80%A7%EF%BC%88attribute%EF%BC%89">Ve 特性（Attribute）</h3>
<p>Ve特性</p>
<pre class="hljs"><code><div>class String{
    [Translate('string.replace&quot;)]
    replace(old:string,newStr:string)(string);
}
//调用说明
def a='字符替换说明';
def newStr='eeee';
string result;
print(result)//'字符替换eeee'
</div></code></pre>
<h3 id="%E5%B1%9E%E6%80%A7%E3%80%81%E7%B4%A2%E5%BC%95%E5%99%A8%E3%80%81%E5%A7%94%E6%89%98%E3%80%81%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95">属性、索引器、委托、匿名方法</h3>
<p>访问器（Accessors）
属性（Property）的访问器（accessor）包含有助于获取（读取或计算）或设置（写入）属性的可执行语句。访问器（accessor）声明可包含一个 get 访问器、一个 set 访问器，或者同时包含二者。例如：</p>
<pre class="hljs"><code><div>//声明类型为 string 的 Code 属性
private code:string;
Code:string
{
   get
   {
      return code;
   }
   set
   {
      code = value;
   }
}
</div></code></pre>
<p>函数、委托、匿名函数</p>
<pre class="hljs"><code><div>class classA {
    //申明了委托，委托可以看定义了一函数类型但没有实现过程
    //相当于定义了类型，但没赋值
     ab:(a:number,b:number)=&gt;number;
     task(fx:(a:number,b:number)=&gt;number):
     {
         return fx(10,300);
     }
}
fun abc(a:int,b:numbr):number
{
    return a+b;
}
fun abcd(a:int,b:number):number
{
    return a-b;
}
def a=new classA;
a.ab=abc;
print(a.ab(10,200));//210
a.ab=abcd;
print(a.ab(10,200))//-190
print(a.task(abc))//310
print(a.task(abcd))//-290
print(a.task((x,y)=&gt;x*y))//3100
</div></code></pre>

</body>
</html>
